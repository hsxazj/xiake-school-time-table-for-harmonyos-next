import axios, { AxiosError, AxiosInstance, AxiosResponse, InternalAxiosRequestConfig } from '@ohos/axios';
import { API_CONFIG } from '../../common/constants/AppConstants';

export interface ApiResponse<T> {
  code: number;
  msg: string;
  data: T;
}

// æ‰©å±•é…ç½®æ¥å£ä»¥åŒ…å«è‡ªå®šä¹‰å±æ€§
interface CustomAxiosRequestConfig extends InternalAxiosRequestConfig {
  metadata?: RequestMetadata;
}

// è¯·æ±‚å…ƒæ•°æ®æ¥å£
interface RequestMetadata {
  startTime: number;
}

// é”™è¯¯å“åº”æ•°æ®æ¥å£
interface ErrorResponseData {
  message?: string;
  code?: number;
}

// è¯·æ±‚é…ç½®æ¥å£
interface RequestConfig {
  method: string;
  url: string;
  data?: Record<string, Object>;
  headers?: Record<string, string>;
}

export class HttpService {
  private static instance: HttpService;
  private axiosInstance: AxiosInstance;

  private constructor() {
    // åˆ›å»ºaxioså®ä¾‹
    this.axiosInstance = axios.create({
      baseURL: API_CONFIG.BASE_URL,
      timeout: API_CONFIG.TIMEOUT,
      headers: {
        'Content-Type': 'application/json'
      }
    });

    // è®¾ç½®æ‹¦æˆªå™¨
    this.setupInterceptors();
  }

  public static getInstance(): HttpService {
    if (!HttpService.instance) {
      HttpService.instance = new HttpService();
    }
    return HttpService.instance;
  }

  /**
   * GETè¯·æ±‚
   */
  public async get<REQ,RES>(url: string, params?: REQ): Promise<ApiResponse<RES>> {
    try {
      const response: AxiosResponse<ApiResponse<RES>> = await this.axiosInstance.get<ApiResponse<RES>>(url, { params });
      return response.data;
    } catch (error) {
      throw this.handleError(error as AxiosError);
    }
  }

  /**
   * POSTè¯·æ±‚
   */
  public async post<T>(
    url: string,
    data?: Record<string, Object>
  ): Promise<ApiResponse<T>> {
    try {
      const response: AxiosResponse<ApiResponse<T>> = await this.axiosInstance.post<ApiResponse<T>>(url, data);
      return response.data;
    } catch (error) {
      throw this.handleError(error as AxiosError);
    }
  }

  /**
   * PUTè¯·æ±‚
   */
  public async put<T>(
    url: string,
    data?: Record<string, Object>
  ): Promise<ApiResponse<T>> {
    try {
      const response: AxiosResponse<ApiResponse<T>> = await this.axiosInstance.put<ApiResponse<T>>(url, data);
      return response.data;
    } catch (error) {
      throw this.handleError(error as AxiosError);
    }
  }

  /**
   * DELETEè¯·æ±‚
   */
  public async delete<T>(url: string): Promise<ApiResponse<T>> {
    try {
      const response: AxiosResponse<ApiResponse<T>> = await this.axiosInstance.delete<ApiResponse<T>>(url);
      return response.data;
    } catch (error) {
      throw this.handleError(error as AxiosError);
    }
  }

  /**
   * é€šç”¨è¯·æ±‚æ–¹æ³• (ä¿æŒå‘åå…¼å®¹)
   */
  public async request<T>(
    method: string,
    url: string,
    data?: Record<string, Object>,
    includeToken: boolean = false
  ): Promise<ApiResponse<T>> {
    try {
      const config: RequestConfig = {
        method: method.toLowerCase(),
        url,
        data: data || {}
      };

      // å¦‚æœéœ€è¦tokenä½†æ²¡æœ‰è®¾ç½®ï¼Œæ‰‹åŠ¨æ·»åŠ 
      if (includeToken) {
        const token = AppStorage.get<string>('token');
        if (token) {
          const headers: Record<string, string> = { 'authorization': token };
          config.headers = headers;
        }
      }

      const response: AxiosResponse<ApiResponse<T>> = await this.axiosInstance.request<ApiResponse<T>>(config);
      return response.data;
    } catch (error) {
      throw this.handleError(error as AxiosError);
    }
  }

  /**
   * è®¾ç½®é»˜è®¤è¯·æ±‚å¤´
   */
  public setDefaultHeader(key: string, value: string): void {
    this.axiosInstance.defaults.headers.common[key] = value;
    console.info(`ğŸ”§ [Header] Set default header: ${key}=${value}`);
  }

  /**
   * ç§»é™¤é»˜è®¤è¯·æ±‚å¤´
   */
  public removeDefaultHeader(key: string): void {
    // ArkTSä¸­ä½¿ç”¨undefinedèµ‹å€¼æ›¿ä»£deleteæ“ä½œ
    this.axiosInstance.defaults.headers.common[key] = undefined;
    console.info(`ğŸ—‘ï¸ [Header] Removed default header: ${key}`);
  }

  /**
   * è·å–axioså®ä¾‹ï¼ˆç”¨äºé«˜çº§ç”¨æ³•ï¼‰
   */
  public getAxiosInstance(): AxiosInstance {
    return this.axiosInstance;
  }

  /**
   * è®¾ç½®è¯·æ±‚å’Œå“åº”æ‹¦æˆªå™¨
   */
  private setupInterceptors(): void {
    // è¯·æ±‚æ‹¦æˆªå™¨
    this.axiosInstance.interceptors.request.use(
      (config: InternalAxiosRequestConfig) => {
        // æ·»åŠ è¯·æ±‚å¼€å§‹æ—¶é—´
        const customConfig = config as CustomAxiosRequestConfig;
        const metadata: RequestMetadata = { startTime: Date.now() };
        customConfig.metadata = metadata;

        // æ·»åŠ è®¤è¯token
        const token = AppStorage.get<string>('token');
        if (token && config.headers) {
          config.headers['authorization'] = token;
        }

        // æ‰“å°è¯·æ±‚æ—¥å¿—
        console.info(`[HTTP Request] ${config.method?.toUpperCase()} ${config.baseURL}${config.url}`);
        if (config.data) {
          console.info(`[Request Data]`, JSON.stringify(config.data));
        }
        if (config.params) {
          console.info(`[Request Params]`, JSON.stringify(config.params));
        }
        console.info(`[Request Time] ${new Date().toLocaleTimeString()}`);

        return config;
      },
      (error: AxiosError) => {
        console.error('[Request Error]', JSON.stringify(error));
        return Promise.reject(error);
      }
    );

    // å“åº”æ‹¦æˆªå™¨
    this.axiosInstance.interceptors.response.use(
      (response: AxiosResponse) => {
        // æ‰“å°å“åº”æ—¥å¿—
        const config = response.config as CustomAxiosRequestConfig;
        const duration = config.metadata?.startTime ? Date.now() - config.metadata.startTime : 0;

        console.info(`[HTTP Response] ${response.status} ${config.method?.toUpperCase()} ${response.config.url}`);
        console.info(`[Response Data]`, JSON.stringify(response.data));
        console.info(`[Response Time] ${duration}ms`);
        console.info(`[Response Size] ${JSON.stringify(response.data).length} bytes`);

        return response;
      },
      (error: AxiosError) => {
        // æ‰“å°é”™è¯¯æ—¥å¿—
        const config = error.config as CustomAxiosRequestConfig;
        const duration = config?.metadata?.startTime ? Date.now() - config.metadata.startTime : 0;

        console.error(`[HTTP Error] ${error.response?.status || 'Network Error'} ${config?.method?.toUpperCase() ||
          'UNKNOWN'} ${config?.url || 'UNKNOWN'}`);
        console.error(`[Error Message] ${error.message}`);
        console.error(`â±[Error Time] ${duration}ms`);

        if (error.response?.data) {
          console.error(`[Error Response]`, JSON.stringify(error.response.data));
        }

        // ç»Ÿä¸€é”™è¯¯å¤„ç†
        if (error.response?.status === 401) {
          // Tokenè¿‡æœŸï¼Œæ¸…é™¤æœ¬åœ°token
          AppStorage.setOrCreate('token', '');
          console.warn('[Auth] Token expired, cleared from storage');
        }

        return Promise.reject(error);
      }
    );
  }

  /**
   * é”™è¯¯å¤„ç†
   */
  private handleError(error: AxiosError): Error {
    let errorMessage = 'ç½‘ç»œè¯·æ±‚å¤±è´¥';

    if (error.response) {
      // æœåŠ¡å™¨å“åº”é”™è¯¯
      const status = error.response.status;
      const data = error.response.data as ErrorResponseData;

      switch (status) {
        case 400:
          errorMessage = data?.message || 'è¯·æ±‚å‚æ•°é”™è¯¯';
          break;
        case 401:
          errorMessage = 'æœªæˆæƒï¼Œè¯·é‡æ–°ç™»å½•';
          break;
        case 403:
          errorMessage = 'ç¦æ­¢è®¿é—®';
          break;
        case 404:
          errorMessage = 'è¯·æ±‚çš„èµ„æºä¸å­˜åœ¨';
          break;
        case 500:
          errorMessage = 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯';
          break;
        default:
          errorMessage = data?.message || `è¯·æ±‚å¤±è´¥ (${status})`;
      }
    } else if (error.request) {
      // ç½‘ç»œé”™è¯¯
      errorMessage = 'ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè®¾ç½®';
    } else {
      // å…¶ä»–é”™è¯¯
      errorMessage = error.message || 'æœªçŸ¥é”™è¯¯';
    }

    console.error('[Error Handler]', errorMessage);
    return new Error(errorMessage);
  }
}