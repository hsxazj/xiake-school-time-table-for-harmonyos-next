import { HttpService } from './HttpService';
import { LoginForm, LoginRequest, LoginResponse } from '../../models/LoginModels';
import { RsaPkcs1Util } from '../../common/utils/RsaPkcs1Util';
import { RSA_PUBLIC_KEY } from '../../common/constants/AppConstants';
import { PreferencesUtil } from '../../common/utils/PreferencesUtil';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { common } from '@kit.AbilityKit';

const DOMAIN = 0x2000; // Login API domain

/**
 * ç™»å½•APIæœåŠ¡ç±»
 * æä¾›ç”¨æˆ·è®¤è¯ç›¸å…³çš„APIæ¥å£
 */
export class LoginApiService {
  private static instance: LoginApiService;
  private httpService: HttpService;

  private constructor() {
    this.httpService = HttpService.getInstance();
  }

  public static getInstance(): LoginApiService {
    if (!LoginApiService.instance) {
      LoginApiService.instance = new LoginApiService();
    }
    return LoginApiService.instance;
  }

  /**
   * ç”¨æˆ·ç™»å½•
   * @param loginForm ç™»å½•è¡¨å•æ•°æ®ï¼ˆåŒ…å«æ˜æ–‡å¯†ç ï¼‰
   * @param context åº”ç”¨ä¸Šä¸‹æ–‡ï¼ˆç”¨äºé¦–é€‰é¡¹å­˜å‚¨ï¼‰
   * @returns Promise<LoginResponse> ç™»å½•ç»“æœï¼ŒåŒ…å«token
   */
  public async login(loginForm: LoginForm, context?: common.UIAbilityContext): Promise<LoginResponse> {
    try {
      hilog.info(DOMAIN, 'LoginApi', `ğŸ” [Login] å¼€å§‹ç™»å½•: ${loginForm.username}`);

      // 1. RSAåŠ å¯†å¯†ç 
      const encryptedPassword = await this.encryptPassword(loginForm.password);

      // 2. æ„å»ºè¯·æ±‚å‚æ•°
      const loginRequest: LoginRequest = {
        username: loginForm.username,
        password: encryptedPassword
      };

      hilog.info(DOMAIN, 'LoginApi', 'ğŸ” [Login] å¯†ç åŠ å¯†å®Œæˆï¼Œå‘é€ç™»å½•è¯·æ±‚');

      // 3. å‘é€ç™»å½•è¯·æ±‚
      // ä½¿ç”¨ä¸“é—¨çš„postLoginæ–¹æ³•å¤„ç†ç™»å½•æ¥å£çš„ç‰¹æ®Šå“åº”æ ¼å¼
      const response: LoginResponse = await this.httpService.postLogin<LoginRequest, LoginResponse>(
        '/login',
        loginRequest
      );

      hilog.info(DOMAIN, 'LoginApi', `ğŸ“¥ [Login] æ”¶åˆ°å“åº”: ${JSON.stringify(response)}`);

      // 4. æ£€æŸ¥å“åº”çŠ¶æ€
      if (response.code === 200 && response.token) {
        hilog.info(DOMAIN, 'LoginApi', 'âœ… [Login] ç™»å½•æˆåŠŸ');

        // 5. ä¿å­˜tokenåˆ°AppStorage
        AppStorage.setOrCreate('token', response.token);
        hilog.info(DOMAIN, 'LoginApi', 'ğŸ’¾ [Login] Tokenå·²ä¿å­˜åˆ°AppStorage');

        // 6. å°†tokenæŒä¹…åŒ–åˆ°é¦–é€‰é¡¹
        if (context) {
          try {
            const preferencesUtil = PreferencesUtil.getInstance();
            preferencesUtil.putValue(context, 'token', response.token);
            hilog.info(DOMAIN, 'LoginApi', 'ğŸ’¾ [Login] Tokenå·²æŒä¹…åŒ–åˆ°é¦–é€‰é¡¹');
          } catch (error) {
            hilog.error(DOMAIN, 'LoginApi', `âš ï¸ [Login] TokenæŒä¹…åŒ–å¤±è´¥: ${JSON.stringify(error)}`);
            // ä¸å½±å“ç™»å½•æµç¨‹ï¼Œç»§ç»­æ‰§è¡Œ
          }
        } else {
          hilog.warn(DOMAIN, 'LoginApi', 'âš ï¸ [Login] æœªæä¾›contextï¼ŒTokenæœªæŒä¹…åŒ–');
        }

        return response;
      } else {
        const errorMsg = response.msg || 'ç™»å½•å¤±è´¥';
        hilog.error(DOMAIN, 'LoginApi', `âŒ [Login] ç™»å½•å¤±è´¥: ${errorMsg}`);
        throw new Error(errorMsg);
      }
    } catch (error) {
      hilog.error(DOMAIN, 'LoginApi', `ğŸ’¥ [Login] ç™»å½•å¼‚å¸¸: ${JSON.stringify(error)}`);

      // ç»Ÿä¸€é”™è¯¯å¤„ç†
      if (error instanceof Error) {
        throw error;
      } else {
        throw new Error('ç™»å½•è¿‡ç¨‹ä¸­å‘ç”ŸæœªçŸ¥é”™è¯¯');
      }
    }
  }

  /**
   * æ£€æŸ¥æ˜¯å¦å·²ç™»å½•ï¼ˆæ˜¯å¦æœ‰æœ‰æ•ˆtokenï¼‰
   * @returns boolean æ˜¯å¦å·²ç™»å½•
   */
  public isLoggedIn(): boolean {
    const token = AppStorage.get<string>('token');
    const hasToken = !!(token && token.trim().length > 0);

    hilog.info(DOMAIN, 'LoginApi', `ğŸ” [Token] æ£€æŸ¥ç™»å½•çŠ¶æ€: ${hasToken ? 'å·²ç™»å½•' : 'æœªç™»å½•'}`);
    return hasToken;
  }

  /**
   * ç”¨æˆ·é€€å‡ºç™»å½•
   * @param context åº”ç”¨ä¸Šä¸‹æ–‡ï¼ˆç”¨äºé¦–é€‰é¡¹å­˜å‚¨ï¼‰
   */
  public logout(context?: Context): void {
    hilog.info(DOMAIN, 'LoginApi', 'ğŸšª [Logout] ç”¨æˆ·é€€å‡ºç™»å½•');

    // æ¸…é™¤AppStorageä¸­çš„token
    AppStorage.setOrCreate('token', '');
    hilog.info(DOMAIN, 'LoginApi', 'ğŸ—‘ï¸ [Logout] AppStorageä¸­çš„Tokenå·²æ¸…é™¤');

    // æ¸…é™¤é¦–é€‰é¡¹ä¸­çš„token
    if (context) {
      try {
        const preferencesUtil = PreferencesUtil.getInstance();
        preferencesUtil.removeValue(context, 'token');
        hilog.info(DOMAIN, 'LoginApi', 'ğŸ—‘ï¸ [Logout] é¦–é€‰é¡¹ä¸­çš„Tokenå·²æ¸…é™¤');
      } catch (error) {
        hilog.error(DOMAIN, 'LoginApi', `âš ï¸ [Logout] æ¸…é™¤é¦–é€‰é¡¹Tokenå¤±è´¥: ${JSON.stringify(error)}`);
      }
    } else {
      hilog.warn(DOMAIN, 'LoginApi', 'âš ï¸ [Logout] æœªæä¾›contextï¼Œé¦–é€‰é¡¹Tokenæœªæ¸…é™¤');
    }
  }

  /**
   * è·å–å½“å‰token
   * @returns string | undefined å½“å‰token
   */
  public getCurrentToken(): string | undefined {
    return AppStorage.get<string>('token');
  }

  /**
   * RSAåŠ å¯†å¯†ç 
   * @param plainPassword æ˜æ–‡å¯†ç 
   * @returns Promise<string> åŠ å¯†åçš„å¯†ç 
   * @private
   */
  private async encryptPassword(plainPassword: string): Promise<string> {
    try {
      hilog.info(DOMAIN, 'LoginApi', 'ğŸ”’ [Encrypt] å¼€å§‹åŠ å¯†å¯†ç ');

      const encryptedPassword = await RsaPkcs1Util.encrypt(RSA_PUBLIC_KEY, plainPassword);

      hilog.info(DOMAIN, 'LoginApi', 'ğŸ”’ [Encrypt] å¯†ç åŠ å¯†æˆåŠŸ');
      return encryptedPassword;
    } catch (error) {
      hilog.error(DOMAIN, 'LoginApi', `ğŸ’¥ [Encrypt] å¯†ç åŠ å¯†å¤±è´¥: ${JSON.stringify(error)}`);
      throw new Error('å¯†ç åŠ å¯†å¤±è´¥ï¼Œè¯·é‡è¯•');
    }
  }
}