import { hilog } from '@kit.PerformanceAnalysisKit';
import { PreferencesUtil } from './PreferencesUtil';
import { ConfigApiResponseData } from '../../models/ConfigModels';
import { CourseInfo } from '../../models/CourseModels';

const DOMAIN: number = 0x0001;
const TAG: string = 'CacheManager';

// ç¼“å­˜keyå¸¸é‡
const CACHE_KEY_PREFIX_SCHEDULE = 'cache_schedule_';
const CACHE_KEY_CONFIG = 'cache_config';
const CACHE_KEY_WEEKS_LIST = 'cache_weeks_list';

// ç¼“å­˜å®¹é‡é™åˆ¶
const MAX_CACHED_WEEKS = 20;

// å®šä¹‰ç¼“å­˜æ•°æ®ç»“æ„çš„æ¥å£
interface CachedScheduleData {
  data: CourseInfo[];
  cachedAt: number;
  version: string;
}

// é…ç½®æ•°æ®ç»“æ„æ¥å£
interface ConfigDataStructure {
  start: Record<string, string[]>;
  end: Record<string, string[]>;
}

interface CachedConfigData {
  data: ConfigDataStructure;
  cachedAt: number;
  version: string;
}

// è¾…åŠ©å‡½æ•°: æ„å»ºè¯¾è¡¨ç¼“å­˜key
function buildScheduleCacheKey(year: string, term: string, week: number): string {
  return `${CACHE_KEY_PREFIX_SCHEDULE}${year}_${term}_${week}`;
}

// è¾…åŠ©å‡½æ•°: æ„å»ºå‘¨æ¬¡æ ‡è¯†ç¬¦
function buildWeekIdentifier(year: string, term: string, week: number): string {
  return `${year}_${term}_${week}`;
}

// è¾…åŠ©å‡½æ•°: è·å–å·²ç¼“å­˜çš„å‘¨æ¬¡åˆ—è¡¨
async function getWeeksList(): Promise<string[]> {
  try {
    const context = getContext();
    const listValue = PreferencesUtil.getInstance().getValue(context, CACHE_KEY_WEEKS_LIST, '') as string;

    if (!listValue) {
      return [];
    }

    return JSON.parse(listValue) as string[];
  } catch (error) {
    hilog.error(DOMAIN, TAG, `âŒ è¯»å–å‘¨æ¬¡åˆ—è¡¨å¤±è´¥: ${JSON.stringify(error)}`);
    return [];
  }
}

// è¾…åŠ©å‡½æ•°: å°†å‘¨æ¬¡æ·»åŠ åˆ°å·²ç¼“å­˜åˆ—è¡¨
async function addWeekToList(year: string, term: string, week: number): Promise<void> {
  try {
    const weekIdentifier = buildWeekIdentifier(year, term, week);
    const weeksList = await getWeeksList();

    // å¦‚æœå·²å­˜åœ¨,å…ˆåˆ é™¤æ—§çš„(ç§»åˆ°æœ€å)
    const index = weeksList.indexOf(weekIdentifier);
    if (index !== -1) {
      weeksList.splice(index, 1);
    }

    // æ·»åŠ åˆ°åˆ—è¡¨æœ«å°¾(æœ€æ–°çš„)
    weeksList.push(weekIdentifier);

    // ä¿å­˜æ›´æ–°åçš„åˆ—è¡¨
    const context = getContext();
    const listValue = JSON.stringify(weeksList);
    PreferencesUtil.getInstance().putValue(context, CACHE_KEY_WEEKS_LIST, listValue, true);
  } catch (error) {
    hilog.error(DOMAIN, TAG, `âŒ æ›´æ–°å‘¨æ¬¡åˆ—è¡¨å¤±è´¥: ${JSON.stringify(error)}`);
  }
}

/**
 * ç¼“å­˜ç®¡ç†å™¨
 * èŒè´£: ç»Ÿä¸€ç®¡ç†è¯¾è¡¨å’Œé…ç½®çš„ç¼“å­˜æ“ä½œ
 */
export class CacheManager {

  /**
   * ä¿å­˜è¯¾è¡¨ç¼“å­˜
   * @param year å­¦å¹´ (å¦‚ "2024")
   * @param term å­¦æœŸä»£å· ("3"=ç¬¬ä¸€å­¦æœŸ, "12"=ç¬¬äºŒå­¦æœŸ)
   * @param week å‘¨æ¬¡
   * @param data è¯¾ç¨‹æ•°æ®åˆ—è¡¨
   */
  public static async saveScheduleCache(
    year: string,
    term: string,
    week: number,
    data: CourseInfo[]
  ): Promise<void> {
    try {
      const cacheKey = buildScheduleCacheKey(year, term, week);
      const cacheData: CachedScheduleData = {
        data: data,
        cachedAt: Date.now(),
        version: '1.0'
      };
      const cacheValue = JSON.stringify(cacheData);

      const context = getContext();
      PreferencesUtil.getInstance().putValue(context, cacheKey, cacheValue, true);

      // å°†è¯¥å‘¨æ·»åŠ åˆ°å·²ç¼“å­˜åˆ—è¡¨
      await addWeekToList(year, term, week);

      hilog.info(DOMAIN, TAG, `âœ… ç¼“å­˜è¯¾è¡¨æˆåŠŸ: ${cacheKey}`);
    } catch (error) {
      hilog.error(DOMAIN, TAG, `âŒ ç¼“å­˜è¯¾è¡¨å¤±è´¥: ${JSON.stringify(error)}`);
      // é”™è¯¯é™é»˜å¤„ç†,ä¸æŠ›å‡º
    }
  }

  /**
   * è·å–è¯¾è¡¨ç¼“å­˜
   * @param year å­¦å¹´
   * @param term å­¦æœŸä»£å·
   * @param week å‘¨æ¬¡
   * @returns è¯¾ç¨‹æ•°æ®åˆ—è¡¨,å¦‚æœä¸å­˜åœ¨åˆ™è¿”å›null
   */
  public static async getScheduleCache(
    year: string,
    term: string,
    week: number
  ): Promise<CourseInfo[] | null> {
    try {
      const cacheKey = buildScheduleCacheKey(year, term, week);
      const context = getContext();
      const cacheValue = PreferencesUtil.getInstance().getValue(context, cacheKey, '') as string;

      if (!cacheValue) {
        hilog.info(DOMAIN, TAG, `ğŸ“­ ç¼“å­˜ä¸å­˜åœ¨: ${cacheKey}`);
        return null;
      }

      const cached: CachedScheduleData = JSON.parse(cacheValue);
      hilog.info(DOMAIN, TAG, `ğŸ“¦ è¯»å–ç¼“å­˜æˆåŠŸ: ${cacheKey}, ç¼“å­˜æ—¶é—´: ${new Date(cached.cachedAt).toLocaleString()}`);

      return cached.data;
    } catch (error) {
      hilog.error(DOMAIN, TAG, `âŒ è¯»å–è¯¾è¡¨ç¼“å­˜å¤±è´¥: ${JSON.stringify(error)}`);
      return null;
    }
  }

  /**
   * ä¿å­˜é…ç½®ç¼“å­˜
   * @param data é…ç½®æ•°æ®
   */
  public static async saveConfigCache(data: ConfigApiResponseData): Promise<void> {
    try {
      // å°†Mapè½¬æ¢ä¸ºæ™®é€šå¯¹è±¡ä»¥ä¾¿JSONåºåˆ—åŒ–
      const startObj: Record<string, string[]> = {};
      const endObj: Record<string, string[]> = {};

      data.start.forEach((value: string[], key: string) => {
        startObj[key] = value;
      });

      data.end.forEach((value: string[], key: string) => {
        endObj[key] = value;
      });

      const configData: ConfigDataStructure = {
        start: startObj,
        end: endObj
      };

      const cacheData: CachedConfigData = {
        data: configData,
        cachedAt: Date.now(),
        version: '1.0'
      };
      const cacheValue = JSON.stringify(cacheData);

      const context = getContext();
      PreferencesUtil.getInstance().putValue(context, CACHE_KEY_CONFIG, cacheValue, true);

      hilog.info(DOMAIN, TAG, `âœ… ç¼“å­˜é…ç½®æˆåŠŸ`);
    } catch (error) {
      hilog.error(DOMAIN, TAG, `âŒ ç¼“å­˜é…ç½®å¤±è´¥: ${JSON.stringify(error)}`);
      // é”™è¯¯é™é»˜å¤„ç†
    }
  }

  /**
   * è·å–é…ç½®ç¼“å­˜
   * @returns é…ç½®æ•°æ®,å¦‚æœä¸å­˜åœ¨åˆ™è¿”å›null
   */
  public static async getConfigCache(): Promise<ConfigApiResponseData | null> {
    try {
      const context = getContext();
      const cacheValue = PreferencesUtil.getInstance().getValue(context, CACHE_KEY_CONFIG, '') as string;

      if (!cacheValue) {
        hilog.info(DOMAIN, TAG, `ğŸ“­ é…ç½®ç¼“å­˜ä¸å­˜åœ¨`);
        return null;
      }

      const cached: CachedConfigData = JSON.parse(cacheValue);

      // å°†æ™®é€šå¯¹è±¡è½¬æ¢å›Map
      const startMap = new Map<string, string[]>();
      const endMap = new Map<string, string[]>();

      Object.keys(cached.data.start).forEach((key: string) => {
        startMap.set(key, cached.data.start[key]);
      });

      Object.keys(cached.data.end).forEach((key: string) => {
        endMap.set(key, cached.data.end[key]);
      });

      hilog.info(DOMAIN, TAG, `ğŸ“¦ è¯»å–é…ç½®ç¼“å­˜æˆåŠŸ, ç¼“å­˜æ—¶é—´: ${new Date(cached.cachedAt).toLocaleString()}`);

      return {
        start: startMap,
        end: endMap
      };
    } catch (error) {
      hilog.error(DOMAIN, TAG, `âŒ è¯»å–é…ç½®ç¼“å­˜å¤±è´¥: ${JSON.stringify(error)}`);
      return null;
    }
  }

  /**
   * é¢„åŠ è½½è¯¾è¡¨ (å½“å‘¨Â±1å‘¨)
   * @param year å½“å‰å­¦å¹´
   * @param term å½“å‰å­¦æœŸ
   * @param currentWeek å½“å‰å‘¨æ¬¡
   * @param fetchScheduleFn è·å–è¯¾è¡¨çš„å‡½æ•°
   */
  public static async preloadSchedules(
    year: string,
    term: string,
    currentWeek: number,
    fetchScheduleFn: (year: string, term: string, week: number) => Promise<CourseInfo[]>
  ): Promise<void> {
    try {
      hilog.info(DOMAIN, TAG, `ğŸ”„ å¼€å§‹é¢„åŠ è½½è¯¾è¡¨: ${year}å­¦å¹´ å­¦æœŸ${term} ç¬¬${currentWeek}å‘¨ Â±1å‘¨`);

      const weeksToLoad = [currentWeek - 1, currentWeek, currentWeek + 1];

      // å¹¶è¡ŒåŠ è½½ä¸‰å‘¨è¯¾è¡¨
      const promises = weeksToLoad.map(async (week) => {
        if (week < 1) {
          hilog.warn(DOMAIN, TAG, `âš ï¸ å‘¨æ¬¡${week}æ— æ•ˆ,è·³è¿‡`);
          return;
        }

        try {
          // å…ˆæ£€æŸ¥ç¼“å­˜æ˜¯å¦å­˜åœ¨
          const cached = await CacheManager.getScheduleCache(year, term, week);
          if (cached) {
            hilog.info(DOMAIN, TAG, `âœ“ ç¬¬${week}å‘¨å·²æœ‰ç¼“å­˜,è·³è¿‡é¢„åŠ è½½`);
            return;
          }

          // è·å–å¹¶ç¼“å­˜æ•°æ®
          const data = await fetchScheduleFn(year, term, week);
          await CacheManager.saveScheduleCache(year, term, week, data);
          hilog.info(DOMAIN, TAG, `âœ“ é¢„åŠ è½½ç¬¬${week}å‘¨æˆåŠŸ`);
        } catch (error) {
          hilog.warn(DOMAIN, TAG, `âš ï¸ é¢„åŠ è½½ç¬¬${week}å‘¨å¤±è´¥: ${JSON.stringify(error)}`);
          // ç»§ç»­å¤„ç†å…¶ä»–å‘¨
        }
      });

      await Promise.all(promises);
      hilog.info(DOMAIN, TAG, `âœ… é¢„åŠ è½½å®Œæˆ`);
    } catch (error) {
      hilog.error(DOMAIN, TAG, `âŒ é¢„åŠ è½½å¤±è´¥: ${JSON.stringify(error)}`);
      // é”™è¯¯é™é»˜å¤„ç†
    }
  }

  /**
   * æ¸…ç†æ—§çš„è¯¾è¡¨ç¼“å­˜ (LRUæ·˜æ±°)
   * ä¿ç•™æœ€å¤š MAX_CACHED_WEEKS å‘¨çš„ç¼“å­˜
   */
  public static async cleanOldScheduleCaches(): Promise<void> {
    try {
      const weeksList = await getWeeksList();

      if (weeksList.length <= MAX_CACHED_WEEKS) {
        hilog.info(DOMAIN, TAG, `å½“å‰ç¼“å­˜${weeksList.length}å‘¨,æ— éœ€æ¸…ç†`);
        return;
      }

      // è®¡ç®—éœ€è¦åˆ é™¤çš„æ•°é‡
      const deleteCount = weeksList.length - MAX_CACHED_WEEKS;
      const weeksToDelete = weeksList.slice(0, deleteCount);

      hilog.info(DOMAIN, TAG, `ğŸ—‘ï¸ å¼€å§‹æ¸…ç†æ—§ç¼“å­˜: åˆ é™¤${deleteCount}å‘¨`);

      const context = getContext();
      weeksToDelete.forEach((weekKey: string) => {
        const cacheKey = `${CACHE_KEY_PREFIX_SCHEDULE}${weekKey}`;
        PreferencesUtil.getInstance().removeValue(context, cacheKey);
        hilog.info(DOMAIN, TAG, `ğŸ—‘ï¸ å·²åˆ é™¤: ${cacheKey}`);
      });

      // æ›´æ–°åˆ—è¡¨
      const newList = weeksList.slice(deleteCount);
      const newListValue = JSON.stringify(newList);
      PreferencesUtil.getInstance().putValue(context, CACHE_KEY_WEEKS_LIST, newListValue, true);

      hilog.info(DOMAIN, TAG, `âœ… æ¸…ç†å®Œæˆ,å‰©ä½™${newList.length}å‘¨ç¼“å­˜`);
    } catch (error) {
      hilog.error(DOMAIN, TAG, `âŒ æ¸…ç†ç¼“å­˜å¤±è´¥: ${JSON.stringify(error)}`);
      // é”™è¯¯é™é»˜å¤„ç†
    }
  }
}
